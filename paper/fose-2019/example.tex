%
% Example file
%

\documentclass{fose2019}           % for pLaTeX2e
%\documentclass[english]{fose2016} % for English papers
%\documentclass[ascii]{fose2016}   % for ASCII pTeX

\usepackage[dvipdfmx]{graphicx}
%\usepackage{amsmath}
\usepackage[largesc]{newtxtext}
\usepackage{newtxmath}
\usepackage{comment}
\usepackage{url}
%\usepackage{tlatex}
%\usepackage{epsfig}
\renewcommand{\UrlBreaks}{\do\\\do\/\do\_\do\-\do\+\do\=}

\title{分散台帳技術の実装における安全性の形式検証}
\etitle{Formal Verification of Safety of a DLT Consensus Algorithm}
\journalhead{Shortened English Title}
\author{齋藤 新}{Shin Saito, IBM Research--Tokyo}
\author{その他}{Others, other}

\newcommand{\TLA}{$\text{TLA}^{+}$}

\begin{document}
\maketitle

\begin{abstract}
本論文では分散台帳技術の安全性を形式仕様記述支援系である\TLA で行った。
定理証明を用いて検証。
2段階のリファインメントによりモデル化と検証を行った。
TLAの使用で得た知見も紹介。
\end{abstract}
\begin{eabstract}
To appear.
\end{eabstract}

\section{序論}

分散台帳技術は仮想通貨 (virtual currency) のプラットフォームとして提案・実装され，その非集中性・耐障害性・耐改竄性により注目を浴びた．
例えば仮想通貨の代表例であるビットコイン\cite{nakamoto:bitcoin}は2009年に運用が開始されてから現在まで，ネットワークを停止させたり，台帳に不整合を発生させたりするような攻撃が成功していない\footnote{ただし，そこからハードフォークにより分裂したビットコインゴールドに対しては2018年に取引結果を覆す51\%攻撃が成功している．これは小規模な通貨においては攻撃に必要な計算能力が少なくてよいためである．}．
その成果を踏まえて，通貨にとどまらず様々なデジタル資産 (暗号資産; crypto-assetとよばれる) を扱えるプラットフォーム\cite{ethereum}が登場するなど，適用範囲が拡大している。

分散台帳技術はインセンティブ設計・暗号理論などを活用することにより，その安全性を担保している．
ところが実装に求められる要件が増大するにつれそのアーキテクチャは複雑化の一途をたどっている．
適切にアーキテクチャが設計されているか，実装がアーキテクチャに忠実に行われているかを確かめることは容易ではない．

例えばEthereumとよばれる実装では，システム上の通貨を利用することによりプログラム (スマートコントラクト) を実行することができる．
その例として，ユーザからの資産を集めて投資しその利益を配分する，DAO (Decentralized Autonomous Organization) と呼ばれるスマートコントラクトが存在する．
ところがスマートコントラクト間で呼び出しが可能なEthereumの機能と，DAOの実装の些細な不具合を利用することにより，DAOが管理する通貨をある限り引き出す攻撃が行われ，数十億円相当の損失となった\cite{dao:codetour}．またIOTAという実装においては暗号部分の設計に瑕疵があることが明らかになった\cite{iota}．台帳側ではなくてクライアント側の実装においてもバグが発生しており，ユーザの保有する通貨が塩漬けになる，ネットワークに不正なトランザクションが放出される，といった例が報告されている．

このような事態を避けるためシステムが適切に設計・実装されていることを保証する方法として，形式検証を用いることが有効である．
特に，一般に行われているテストベースの設計・開発と比べて次のような利点がある．
まず，テストでは不可能な「設計の正しさ」を検証することができる．
また，全状態を網羅する検証を行うことにより，分散システムにおいて重要であるコーナーケースにおける振る舞いについても確認することができる．
さらに，検証により設計の前提条件などが明確となることにより，分析や改良をより確実・容易に行うことができるようになる．
一般に，形式検証にかかるコストおよび必要知識はテストのそれに比べて大きく，人手を必要とする場合もあるが，そのメリットは不具合による損失・被害の大きさに見合うものであると思われる．

本論文ではプライベート型分散台帳技術の一実装であるHyperledger Fabric (以下，Fabric) を対象とし，コンセンサスに関するコア部分を形式検証系である\TLA で検証する．
Fabricは処理性能の追求などのため，一般的なブライベート型の分散台帳とは異なるアーキテクチャを採っている．
そのためアーキテクチャが設計者の意図する分散台帳の性質を満たすかは自明ではない．
検証は定理証明により行い，より抽象的なモデルからの詳細化 (refinement) を多段階で行うことによりその安全性を証明する．
これにより証明を簡潔に行うことができ，モデルを拡張・再利用するための適切な抽象化が得られる．

本論文の構成は以下の通りである．\ref{sec:dlt}節では分散台帳技術およびFabricについて概説する．
\ref{sec:tla}節では本論文で使用する形式仕様検証系である\TLA について紹介する．
\ref{sec:verification}節ではFabricの\TLA による検証について詳細を説明する．
\ref{sec:consider}節・\ref{sec:related}節ではそれぞれ，得られた知見および関連研究について述べる．

\section{分散台帳技術}\label{sec:dlt}
分散台帳技術はネットワーク上に散在するノード間で状態を同期するシステムおよびアーキテクチャの名称である．
状態は任意のデータでよいが，キー・バリュー・ストア (KVS) であることが多い．
ネットワーク上のノードに対して，クライアントはノードの状態を変更するためのリクエストであるトランザクションを送信できる．
ほとんどの実装では受け取ったトランザクション列を同期することにより，その適用結果であるノード状態の同期を行う．

ブロックチェーンとは分散台帳のアーキテクチャのひとつである．
複数のトランザクションをまとめてブロックに格納し，ブロック単位でノード間のデータ共有を行う．
ブロックをチェーン上に並べそれらの同期を取る．
各ブロックには直前のブロックのハッシュ値を格納することによりブロックの改竄を防止する．
なお，ブロックチェーンの同期を取ることをコンセンサスとよぶ．

分散台帳の実装は参加者\footnote{ここでいう参加者とは，ネットワークに参加するノード，および，
クライアントがトランザクションを発行する際に使用するユーザアカウントのことである．}の制限の有無により，2つの種類に大別される．
パブリック型 (public/permissionless blockchain) は参加者 (ノードおよびクライアント) の資格・数に制限がない．そのため，コンセンサスには計算量などをもとにしたインセンティブベースのアルゴリズムが用いられる．
例えばビットコインのコンセンサスにはハッシュの計算量をもとにしたプルーフ・オブ・ワーク (PoW) が使われている．
一方，パーミッション型\footnote{プライベート型，コンソーシアム型などともよばれる．} (permissioned blockchain) においては認証ノードに許可された参加者しか加われない．また，ある時点においては参加ノードの数が固定されている．これは1980年代から研究されていた分散合意の問題設定であり，コンセンサスには多数決ベースのアルゴリズムが使用される．例えばHyperledger Fabricでは，バージョン0においてPBFTアルゴリズム\cite{Castro:PBFT:1999}が使用されていた．

\subsection{ビザンチン耐性}

分散台帳技術においてはノードやネットワークの障害に対して耐性がある，すなわち状態の同期が正しく行われることが要求される．
ここでいうノードの障害は故障などによる停止のほか，ノードで動作するプログラムにバグがある，ノードに悪意がある，などの理由によりコンセンサス・プロトコルに従わない状況を含む．
このような障害はビザンチン将軍問題\cite{byzgen}にちなんでビザンチン障害とよばれる．
ビザンチン障害に対して耐性を持つことをビザンチン耐性 (Byzantine Fault Tolerance; BFT) とよぶ．

既知の結果として，参加ノードのうち高々 $f$ 台がビザンチン障害にある場合において，ネットワークが耐性を持つためには最低$3f+1$台のノードが必要であることが知られている\cite{bft}．

\subsection{Hyperledger Fabric}

Hyperledger Fabric\cite{fabric} (以下，Fabric) はパーミッション型ブロックチェーンの1実装であり，Hyperledgerコンソーシアムの1プロジェクトである．
ビジネス用途向けに様々なアーキテクチャの工夫がなされている．
Fabricはコンソーシアム型とよばれるアーキテクチャを採用する．
ネットワークは複数の組織からなり，各組織の認証機関が参加を許可するノードおよびユーザを指定する．
組織内の参加者は互いに信用するモデルである．

Fabricでは各ノードをDockerコンテナとして動作させることにより，OSを問わずに稼働させることができる．
また，スマートコントラクトも独立したコンテナとすることにより，複数の言語\footnote{v1.4の時点ではGo, Node.js, Javaをサポートする．}がサポートされている．

処理性能向上のため，Fabricバージョン1以降では一般に見られる分散台帳の実装とは異なり，トランザクションを整列する専用のノードを持つこと，トランザクションの提出に先立ってスマートコントラクトを仮実行すること，を特徴とするアーキテクチャが採用されている．
本論文の目的はこの安全性を検証することである．
コンセンサス・アルゴリズムの詳細については\ref{sec:verification}節で説明する．

\section{形式検証系\TLA}
\label{sec:tla}
形式検証系は対象とするシステムを数学的に記述し，それが満たす性質を機械的に検証するためのシステムである．
分散台帳技術の検証においては並列システムおよびその性質を記述できる検証系が求められる．

本研究ではLamportらにより提案および開発された\TLA を使用する．
\TLA は集合論と時相論理に基づく言語，TLA (Temporal Logic of Actions) で記述されたシステムを検証するツール群である．
検証器としてモデル検査器TLCが提供されていたが，後に定理証明システムTLAPSが追加され，より大規模なシステムの検証に耐えるようになった．
さらに近年，手続き型言語PlusCalおよびTLAへの変換器が提供されたこともあり，ソフトウェアエンジニアなどにも使用しやすくなった．
その結果，企業でのソフトウェア開発への適用例が増えている\cite{}．
上記各ツールに加えてEclipseベースのIDEであるTLA Toolboxが提供されている．
本論文ではTLA Toolboxのバージョンx.y.zおよびTLAPSのバージョンx.y.zを使用した．

\subsection{\TLA}

blank

\section{Hyperledger Fabricの安全性検証}
\label{sec:verification}

\newcommand{\s}[1]{\mathbf{S_{#1}}}
\newcommand{\p}[1]{\langle #1 \rangle}
\newcommand{\ra}{\Rightarrow}

状態遷移系$\s1,\s2$において、$\s1$の (観測可能な) 状態の遷移列が$\s2$のそれでもあるとき、$\s1$は$\s2$のrefinementであるとよぶ。
$\s1$が$\s2$のrefinementであり$\s2$が安全性を満たす場合には$\s1$も満たすことが示される。

本論文ではこれを用いてMVCC台帳が台帳仕様の正しい実装であることを示す。

\subsection{Refinement Mappingを用いた安全性証明}

Abadiらは、状態遷移系$\s1,\s2$において、$\s1$の状態を$\s2$の状態に写す関数で、ある条件を満たすものをrefinement mappingと定義し、
mappingが存在する場合には$\s1$は$\s2$のrefinementになること (およびある条件下ではその逆が成り立つこと) を示した [Abadi and Lamport '88]。

ここではより限定された形のモデルを扱う。低位のモデル (= 実装)、高位のモデル (= 要求仕様) をそれぞれ $\s1$、$\s2$ とし、さらに $\s2$ は内部状態を持たないとする、つまり $\Sigma_2 = \Sigma_E$ とみなす。
またどちらのモデルも自明な liveness property を持つ、つまり $L_i = \Sigma_i^{\omega}$ とする。
このとき refinement mapping $f$ とは以下の条件を満たす $\Sigma_1$ から $\Sigma_2$への写像である。

\begin{enumerate}
\item すべての $s\in\Sigma_1$ について、$f(s) = \Pi_E(s)$
\item $f(F_1) \subseteq F_2$
\item $\p{ s,t }\in N_1$ ならば $\p{f(s), f(t)} \in N_2$ または $f(s)=f(t)$ である 
\end{enumerate}

このとき条件1より $f(\p{e, y}) = e$、つまり$f$は$\Sigma_E$への射影関数であることがわかる。これに従い前記条件2および3を書き直すと以下のようになる。

\begin{enumerate}
\item[2'] $\{ e \mid \p{e,y}\in F_1 \} \in F_2$
\item[3'] $\p{(e,y), (e',y')}\in N_1$ ならば $\p{e,e'} \in N_2$ または $e=e'$ である 
\end{enumerate}

さらに $\s1$ において、外部状態 $e$ は内部状態 $y$ の関数 $\pi$ であり、状態機械$\s1$は内部状態のみに依存して定義されていると仮定する。
このとき、前記条件はさらに以下のように変形できる。

\begin{enumerate}
\item[2''] $y \in F_1 \ra \pi(y) \in F_2$
\item[3''] $\p{y,y'}\in N_1$ ならば $\p{\pi(y),\pi(y')} \in N_2$ または $\pi(y)=\pi(y')$ である 
\end{enumerate}

これは\TLA においては$e \triangleq \pi(y)$とおいたうえで$L(y)!Spec \ra H(e)!Spec$を示すことに等しい。
これは前述の2''および3''を示すことにより\TLA で証明できる。

\begin{alignat}{2}
{} &\land L(y)!Init \ra H(e)!Init \\
{} &\land Inv \land L(y)!Next \ra Inv' \land \begin{aligned}[t]
	{}&\lor H(e)!Next \\
	{}&\lor \textsc{unchanged}\p{a,b,c}
	\end{aligned}
\end{alignat}

\section{考察}

\subsection{\TLA におけるモデル化と証明の難易度}
\TLA に

\subsection{モデルと実装}

形式検証の課題の1つとして，モデルと実装\footnote{ここでいう実装は，プログラミング言語による実装を指す．}の乖離がある．

まず，先に要求仕様としてのモデルを作成・検証し，それをもとにコードを実装する場合を考える．
分散プロトコルを一からデザインする場合にはこちらのアプローチが望ましい．
このとき，モデルが正しいことを検証できたとしても，実装へ抽出または変換する際に誤りがあると形式検証を行った意味が失われる．
この主要な原因としてはモデルの記述力が低いことなどに起因してモデルが単純化されすぎている場合と，逆に記述力が高すぎるため，プログラミング言語で実装可能なコードに変換する際に誤りが混入する場合があると考えられる．
\TLA の場合は後者にあたる可能性が大きい．
\TLA におけるoperationはマクロ的な働きをする上に，様々なデータ型や操作が集合およびその上の演算として表現されている．
集合には内包表記が使用可能で，さらに非決定的代入も存在する．
これらは\TLA で記述する際には頻出するが，例えばGo言語のような低レベル言語で直接に実装するのは難しい．
この場合には，上記のモデルをいったん実装に近い形に詳細化して，それをプログラムに変換するのが望ましい．

一方，実装がすでに存在し，その性質を検証する場合にはモデルが実装の振る舞いを正しく反映しているかが問題となる．
例えば\TLA ではPlusCalという手続き型言語からTLAへの変換器が提供されており，これと同様に実装から自動的にモデルを抽出することが望ましい．
Hyperledger Fabricの場合はすでに実装があり，バージョンアップが頻繁であるため，現在のところはこのアプローチが現実的であると思われる．
しかし実際に動作するレベルのコードから変換して検証器が耐えうる程度の規模のモデルに収まるかについては未知数である．

\section{関連研究}
\label{sec:related}

これまでに様々な形式検証系が研究されている．

関数型言語をベースとしたものではCoq, Agda, Isabelle/HOLが著名である．
これらは帰納データ型とタクティクに基づく豊富な証明能力があるが，デフォルトでは時相論理を扱えないため今回は採用しなかった．
なお，CoqにLogic of Eventsと呼ばれる理論を導入し，PBFTアルゴリズムの検証を行った研究がある\cite{loe}．
Coqには証明からプログラムを抽出する機能があり，形式検証で問題になるモデルと実装の乖離を防ぐ意味で有用な手法であると思われる．

\TLA ではPaxos，Raftを始めとする分散合意プロトコルが検証されている．

状態遷移系 (Kripke構造) をベースとするものには\TLA の他にEvent-BやNuSMVが挙げられる．
前者は定理証明ベースであり後者はモデル検査器を使用する．
これらの中では\TLA がもっとも記述の自由度が高い．
たとえばEvent-Bはモジュールの概念がないため，大規模なシステムを記述することにはあまり向かない．
また，基本的なデータ型しか存在しないために実装に近い記述をすることには困難が伴う．
時相論理で性質を記述することができないことも欠点である．
NuSMVは時相論理で性質を記述することができ，モジュールの概念がある．
ただし複数のモジュールが非同期的に動作するようなモデルを容易には書きにくい\footnote{厳密に言うと現在はその機能があるが削除予定である．}．またモデル検査の都合上有限の状態遷移しか許されない．

また，並行プロセス計算である$\pi$計算に基づくものとしてProVerifがある．
これはセキュリティプロトコルの検証に特化しており，「イベントAが起きたときには必ず過去にイベントBが起きている」といった他の検証器にはない，後ろ向きの性質が記述できるが，一方で記述できない時相論理式が多い．
そのため今回のような一般の分散システム検証には不向きである．

\section{まとめ}
本論文ではパーミッション型の分散台帳技術であるHyperledger Fabricの安全性に関する形式検証を行った．
Fabricのコンセンサスアルゴリズムの主要部分を取り出したものについて，低レベルのモデル (実装) が高レベルのモデル (仕様) を詳細化していることを証明することによりその安全性を検証した．
形式検証系には集合論および時相論理をベースとする\TLA を用いた．
豊富なデータ型とSMTソルバなどを用いた定理証明器により，シンプルに証明を構築することができた．
現在の\TLA のモデル検査器の性能が向上すれば，定理証明とモデル検査を組み合わせることにより，さらに効率の良い検証が可能になると思われる．
今後の研究はFabricの独自機能をさらに盛り込むこと，プログラミング言語による実装とモデルの対応を正しく取ることについて取り組んでいきたい．

\begin{comment}
\section{表と図}

表の例を表\ref{tab:example}に，
図の例を図\ref{fig:example}に示します．

\begin{table}[htbp]
  \centering
  \caption{表の例} \label{tab:example}
  \begin{tabular}{|l|l|l|}\hline
    FOSE2013 & ソフトウェア工学の基礎 XX & 岡野 浩三，関澤 俊弦 編 \\ \hline
    FOSE2014 & ソフトウェア工学の基礎 XXI& 花川 典子，尾花 将輝 編\\ \hline
    FOSE2015 & ソフトウェア工学の基礎XXII & 青木 利晃，豊島 真澄 編\\ \hline
    FOSE2016 & ソフトウェア工学の基礎XXIII & 阿萬 裕久，横川 智教 編\\ \hline
    FOSE2017 & ソフトウェア工学の基礎XXIV & 吉田 敦，福安 直樹 編\\ \hline
    FOSE2018 & ソフトウェア工学の基礎XXV & 伊藤 恵，神谷 年洋  編\\ \hline
  \end{tabular}
\end{table}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{fose2005logo.eps}
%  \epsfig{file=fose2005logo.eps,width=\textwidth}
  \caption{図の例(FOSE2005のロゴを使わせてもらっております)}
  \label{fig:example}
\end{figure}
\end{comment}


\acknowledgements{test}
あれば書く。

\bibliographystyle{junsrt}
\bibliography{mybib}
\end{document}
