%
% Example file
%

\documentclass{fose2019}           % for pLaTeX2e
%\documentclass[english]{fose2016} % for English papers
%\documentclass[ascii]{fose2016}   % for ASCII pTeX

\usepackage[dvipdfmx]{graphicx}
%\usepackage{amsmath}
\usepackage[largesc]{newtxtext}
\usepackage{newtxmath}
\usepackage{comment}
\usepackage{listings}
\lstset{numbers=left, breaklines=true,columns=fullflexible, numberstyle=\scriptsize, basicstyle=\ttfamily\scriptsize}
%frame=tb
\usepackage{url}
%\usepackage{tlatex}
%\usepackage{epsfig}
\renewcommand{\UrlBreaks}{\do\\\do\/\do\_\do\-\do\+\do\=}

\title{分散台帳の実装における安全性の形式検証}
\etitle{Formal Verification of Safety of a Blockchain Consensus Algorithm}
%\journalhead{Shortened English Title}
\author{齋藤 新}{Shin Saito, IBM Research--Tokyo}

\newcommand{\TLA}{$\text{TLA}^{+}$}

\begin{document}
\maketitle

\begin{abstract}
本論文では分散台帳技術におけるコンセンサス・アルゴリズムの安全性を形式的に検証した．
パーミッション型分散台帳であるHyperledger Fabricを対象とし，検証には形式仕様フレームワークである\TLA を用いた．
仕様を2段階に詳細化するというアプローチでモデル化を行い，定理証明器を用いて検証を行った．
その結果，再利用性が高い適切な抽象化が得られ，見通しのよい検証の道筋を立てることができた．
\end{abstract}
\begin{eabstract}
This paper formally verifies the safety of a consensus algorithm used in a DLT implementation.
The target DLT is Hyperledger Fabric, one of the permissioned blockchains.
We use a formal verification framework \TLA.
We describe the system as multi-level models and prove its refinement relation using its theorem prover.
This gives us reusable abstraction model and good perspective for verification.
\end{eabstract}

\section{序論}

分散台帳技術は仮想通貨 (virtual currency) のプラットフォームとして提案・実装され，その非集中性・耐障害性・耐改竄性により注目を浴びた．
例えば仮想通貨の代表例であるビットコイン\cite{nakamoto:bitcoin}は2009年に運用が開始されてから現在まで，ネットワークを停止させたり，台帳に不整合を発生させたりするような攻撃が成功していない\footnote{ただし，そこからハードフォークにより分裂したビットコインゴールドに対しては2018年に取引結果を覆す51\%攻撃が成功している．}．
その成果を踏まえて，通貨にとどまらず様々なデジタル資産 (暗号資産; crypto-assetとよばれる) を扱えるプラットフォーム\cite{ethereum}が登場するなど，適用範囲が拡大している。

分散台帳技術はインセンティブ設計・暗号理論などを活用することにより，その安全性を担保している．
ところが実装に求められる要件が増大するにつれそのアーキテクチャは複雑化の一途をたどっている．
適切にアーキテクチャが設計されているか，実装がアーキテクチャに忠実に行われているかを確かめることは容易ではない．

例えばEthereumとよばれる実装では，システム上の通貨を利用することによりプログラム (スマートコントラクト) を実行することができる．
%その例として，ユーザからの資産を集めて投資しその利益を配分する，DAO (Decentralized Autonomous Organization) と呼ばれるスマートコントラクトが存在する．
ところがプラットフォームの仕様と実装の些細な不具合を悪用し，スマートコントラクトが管理する通貨をある限り引き出す攻撃が行われ，数十億円相当の損失となった\cite{dao:codetour}．
%またIOTAという実装においては暗号部分の設計に瑕疵があることが明らかになった\cite{iota}．
台帳側ではなくてクライアント側の実装においてもバグによる損失が報告されている．

このような事態を避けるためシステムが適切に設計・実装されていることを保証する方法として，形式検証を用いることが有効である．
%特に，一般に行われているテストベースの設計・開発と比べて次のような利点がある．
まず，テストでは不可能な「設計の正しさ」を検証することができる．
また，全状態を網羅する検証を行うことにより，分散システムにおいて重要であるコーナーケースにおける振る舞いについても確認することができる．
%さらに，検証により設計の前提条件などが明確となることにより，分析や改良をより確実・容易に行うことができるようになる．
%一般に，形式検証にかかるコストおよび必要知識はテストのそれに比べて大きく，人手を必要とする場合もあるが，そのメリットは不具合による損失・被害の大きさに見合うものであると思われる．

本論文ではプライベート型分散台帳技術の一実装であるHyperledger Fabric (以下，Fabric) を対象とし，コンセンサスに関するコア部分を形式検証系である\TLA で検証する．
%Fabricは処理性能の追求などのため，一般的なブライベート型の分散台帳とは異なるアーキテクチャを採っている．
%そのためアーキテクチャが設計者の意図する分散台帳の性質を満たすかは自明ではない．
検証は定理証明により行い，より抽象的なモデルからの詳細化 (refinement) を多段階で行うことによりその安全性を証明する．
これにより証明を簡潔に行うことができ，モデルを拡張・再利用するための適切な抽象化が得られる．

本論文の構成は以下の通りである．\ref{sec:dlt}節では分散台帳技術およびFabricについて概説する．
\ref{sec:tla}節では本論文で使用する形式仕様検証系である\TLA について紹介する．
\ref{sec:verification}節ではFabricの\TLA による検証について詳細を説明する．
\ref{sec:consider}節・\ref{sec:related}節ではそれぞれ，得られた知見および関連研究について述べる．

\section{分散台帳技術}\label{sec:dlt}
分散台帳技術はネットワーク上に散在するノード間で状態を同期するシステムおよびアーキテクチャの名称である．
状態は任意のデータでよいが，キー・バリュー・ストア (KVS) であることが多い．
ネットワーク上のノードに対して，クライアントはノードの状態を変更するためのリクエストであるトランザクションを送信できる．
ほとんどの実装では受け取ったトランザクション列を同期することにより，その適用結果であるノード状態の同期を行う．

ブロックチェーンとは分散台帳のアーキテクチャのひとつである．
複数のトランザクションをまとめてブロックに格納し，ブロック単位でノード間のデータ共有を行う．
ブロックをチェーン上に並べそれらの同期を取る．
各ブロックには直前のブロックのハッシュ値を格納することによりブロックの改竄を防止する．
なお，ブロックチェーンの同期を取ることをコンセンサスとよぶ．

分散台帳の実装は参加者\footnote{ここでいう参加者とは，ネットワークに参加するノード，および，
クライアントがトランザクションを発行する際に使用するユーザアカウントのことである．}の制限の有無により，2つの種類に大別される．
パブリック型 (public/permissionless blockchain) は参加者 (ノードおよびクライアント) の資格・数に制限がない．そのため，コンセンサスには計算量などをもとにしたインセンティブベースのアルゴリズムが用いられる．
例えばビットコインのコンセンサスにはハッシュの計算量をもとにしたプルーフ・オブ・ワーク (PoW) が使われている．
一方，パーミッション型 (permissioned blockchain) においては認証ノードに許可された参加者しか加われない．また，ある時点においては参加ノードの数が固定されている．これは1980年代から研究されていた分散合意の問題設定であり，コンセンサスには多数決ベースのアルゴリズムが使用される．例えばFabricでは，バージョン0においてPBFTアルゴリズム\cite{Castro:PBFT:1999}が使用されていた．

\subsection{ビザンチン耐性}

分散台帳技術においてはノードやネットワークの障害に対して耐性があることが要求される．
ここでいうノードの障害は故障などによる停止のほか，ノードに悪意がある，などの理由によりコンセンサス・プロトコルに従わない状況を含む．
このような障害は「ビザンチン将軍問題」\cite{byzgen}にちなんでビザンチン障害とよばれる．
ビザンチン障害に対して耐性を持つことをビザンチン耐性 (Byzantine Fault Tolerance; BFT) とよぶ．
既知の結果として，参加ノードのうち高々 $f$ 台がビザンチン障害にある場合において，ネットワークが耐性を持つためには最低$3f+1$台のノードが必要であることが知られている．%\cite{bft}．

\subsection{Hyperledger Fabric}

Hyperledger Fabric\cite{fabric} (以下，Fabric) はパーミッション型ブロックチェーンの1実装であり，Hyperledgerコンソーシアムの1プロジェクトである．
%ビジネス用途向けに様々なアーキテクチャの工夫がなされている．
Fabricはコンソーシアム型とよばれるアーキテクチャを採用する．
ネットワークは複数の組織からなり，各組織の認証機関が参加を許可するノードおよびユーザを指定する．
組織内の参加者は互いに信用するモデルである．

%Fabricでは各ノードをDockerコンテナとして動作させることにより，OSを問わずに稼働させることができる．
%また，スマートコントラクトも独立したコンテナとすることにより，複数の言語\footnote{v1.4の時点ではGo, Node.js, Javaをサポートする．}がサポートされている．

処理性能向上のため，Fabricバージョン1以降では一般に見られる分散台帳の実装とは異なるアーキテクチャが採用されている．
本論文の目的はこの安全性を検証することである．
コンセンサス・アルゴリズムの詳細については\ref{sec:verification}節で説明する．

\section{形式検証系\TLA}
\label{sec:tla}

\newcommand{\s}[1]{\mathbf{S_{#1}}}
\newcommand{\p}[1]{\langle #1 \rangle}
\newcommand{\ra}{\Rightarrow}

%形式検証系は対象とするシステムを数学的に記述し，それが満たす性質を機械的に検証するためのシステムである．
%分散台帳技術の検証においては並列システムおよびその性質を記述できる検証系が求められる．

本研究ではLamportらにより提案および開発された形式検証フレームワークである\TLA\cite{tla}を使用する．
\TLA は集合論と時相論理に基づく言語であるTLAで記述されたシステムを検証するツール群である．
検証器としてモデル検査器TLCが提供されていたが，後に定理証明システムTLAPSが追加され，より大規模なシステムの検証にたえるようになった．
%さらに近年，手続き型言語PlusCalおよびTLAへの変換器が提供されたこともあり，ソフトウェアエンジニアなどにも使用しやすくなった．
%その結果，企業でのソフトウェア開発への適用例が増えている\cite{}．
上記各ツールに加えてEclipseベースのIDEであるTLA Toolboxが提供されている．
%本論文ではTLA Toolboxのバージョンx.y.zおよびTLAPSのバージョンx.y.zを使用した．

\subsection{仕様記述言語TLA}
\TLA で使用する仕様記述言語はTLA (Temporal Logic of Actions) と呼ばれる．
詳細は\cite{tla}に譲るが，掲載されているサンプルHour Clock (図\ref{fig:hc}) を参考にしたコードを用いて概要を説明する．
なお，図では仕様がASCII文字列で表記されているが，本文ではそれらに対応する数学的な記法を用いる．
\begin{figure}[tbh]
\centering
\begin{minipage}{0.95\linewidth}
\lstinputlisting{hc.tla}
\caption{Hour ClockのTLAによる記述例}\label{fig:hc}
\end{minipage}
\end{figure}

TLAではモジュールが1つの状態遷移系を記述する単位である．
例ではモジュール \textit{HourClock} を定義している．
\textsc{extends}宣言で他のモジュールを取り込むことができる．
%\textsc{extends} $M$ とすることによりモジュール $M$ 内の宣言・定義にアクセスすることができる．
各種ライブラリもモジュールとして定義されており，ここでは自然数に関するライブラリである \textit{Naturals} をインポートしている．
モジュールの状態変数は\textsc{variable(s)}宣言で，定数は\textsc{constant(s)}宣言で定義する．
これらはすべて集合であり，各々の自然数も定義された集合であるとみなされる．
例では状態変数として \textit{hr} を定義している．
定数は定義していない．

\textit{Init}の定義から始まるその後の行はすべて定義である．
システムの記述に必要な値・集合・述語などはすべて定義として表現される．
なお，定義の展開はマクロ的に行われる．

TLAにおいて，状態遷移系は初期条件，および，状態遷移における事前・事後条件に関する論理式として定義される．
\textit{Init} は初期条件を定義する．ここでは \textit{hr} は1から12までのいずれかであると定義している．
このように非決定的な定義が可能であることがTLAの特徴の1つである．
\textit{Next} は状態遷移を定義している．これは事前条件と事後条件の論理積で表現される．
その際に，$\mathit{hr}'$ のように状態変数にプライム記号がついたものは「次の状態における変数の値」を表す．
例では \textit{hr} の値が12でなければ\footnote{~\url{#} または \url{/=} で $\neq$ を表す．}，次の状態では $\mathit{hr}+1$ になり，12であれば1になる，としている．
なお例では事前条件が指定されていないので，すべての状態において遷移が可能である．

これをまとめてシステムの振る舞い \textit{Spec} は時相論理式の定義 $\mathit{Spec} \triangleq \mathit{Init} \land {\square [ \mathit{Next} ]_{\mathit{hr}} }$ で与えられる．
ここで $[ \mathit{Next} ]_{\mathit{hr}}$ は $ \mathit{Next} \lor \textsc{unchanged $\mathit{hr}$}$ を表し，
さらに \textsc{unchanged} $\mathit{hr}$ は $\mathit{hr}' = \mathit{hr}$ を表す．
これは状態が変化しないステップ，stutteringを意味している．
TLAのすべての時相論理式はstutteringに対して不変であることが求められており，実際に \textit{Spec} の定義式もそうなっている．

最後に証明したいシステムの性質が時相論理式\textit{TypeSafety}として \textsc{theorem} 宣言で定義されている．
例では不変条件，つねに \textit{hr} の値が1から12までのいずれかであること，が表現されている．
これは\TLA ではtype invariantと呼ばれる不変条件であり，安全性の一種である．
一般に，不変条件の成立は $\mathit{Spec} \ra \square \mathit{Inv}$ として表現される．
なお，例では定理の証明が書かれていない．
実際には仕様の記述者が証明支援系TLAPSを使って構築していくこととなる．

\section{\TLA によるHyperledger Fabricの安全性検証}
\label{sec:verification}

ここではFabricのコンセンサスアルゴリズムの一部を単純化し，その安全性を\TLA の定理証明支援系TLAPSにより証明する．
なお，仕様および証明の全体については\url{https://github.com/shinsa82/fabric-formal-model}から入手可能である．

\subsection{Hyperledger Fabricのコンセンサス・アルゴリズム}
Fabricのコンセンサス・アルゴリズムは処理性能の向上，台帳不整合の早期発見などを目的として，他の実装には見られない，MVCC (Multiversion Concurrency Control) をベースとしたものが用いられている．

例として，台帳をキーとして各ユーザ名，値としてその残高が記載されたKVSであるとし，ユーザAからBに送金する例を考える．
ここで，KVSの各エントリはキーおよび値に加えてバージョンを保持している構造とする．
このバージョンはエントリに書き込みがあるたびにインクリメントされる．

ある時点において，Aの残高が400でそのバージョンはv2 (以下 $(A,400,v2)$ と書く)，Bは $(B,300,v1)$ であるとする．
AからBへ100を送金するトランザクションに対して，具体的なアルゴリズムは以下のようになる．
ただし単純化のためトランザクションをブロックにまとめる処理をせず，トランザクション単位で処理を行うものとする．

\begin{enumerate}
\item クライアントはAからBへの送金トランザクションを作成．各ノードにその仮実行 (simulation) を依頼する．
\item 各ノードは送金スマートコントラクトを仮実行し，その結果であるread-write set (以下 RWSet) を返す．
Read-setにスマートコントラクトが仮実行中に読み出したキーとそのバージョンが記録される．
例では$\{ (A, v2), (B, v1) \}$である．
Write-setには仮実行中に書き込んだキーとその値が記録される．
例では$\{ (A, 300), (B, 400) \}$である．
\item クライアントは各ノードから返るRWSetたちを元のトランザクションにエンドースメントとして含め，オーダラー (順序付けサービス) と呼ばれる特殊ノードに送る．ここで，全ノードからRWSetが返るとは限らないし，(ビザンチン障害を仮定するので) その結果が正しいとは限らないことに注意する．
\item オーダラーは複数のクライアントから到達するトランザクションたちを一列に並べて，順にノードにブロードキャストする．
\item ノードはオーダラーからトランザクションを受け取ったらその検証 (MVCC検証) を行う．
\begin{enumerate}
\item エンドースメントが3個未満である場合には検証失敗とする．
\item \label{a} エンドースメントが3個以上ある場合，そのうち2つ以上のRWSetが一致する場合はそれを正として次のステップに進む．そうでない場合は検証失敗とする．
\item 前ステップで正としたRWSetのread-setのすべてのエントリについて，そのバージョンが「現在のノードの対応エントリのバージョン」と等しい場合には検証成功とし，そうでない場合には検証失敗とする．
\end{enumerate}
検証に失敗した場合はそのトランザクションにinvalidフラグをつけて無視する．
検証に成功した場合はそのトランザクションをブロックチェーンに追記し，RWSetを現在の状態に適用する．その結果，各ノードにおけるKVSのエントリは $(A,300,v3)$ および $(B,400,v2)$ となる．
\end{enumerate}

上記のアルゴリズムは高々1台のノードがビザンチン障害にある場合については期待通りに動作するはずである．
すなわち，その条件下において，ステップ\ref{a}で正とされるRWSetはread-set: $\{ (A, v2), (B, v1) \}$, write-set: $\{ (A, 300), (B, 400) \}$となるはずである．
またMVCC検証に成功した場合，送金トランザクションを実行して台帳の状態を更新する必要はなく，RWSetをコミットすることで同じ効果が得られるはずである．

\subsection{Refinementによる安全性証明}

Fabricのコンセンサス・アルゴリズム安全性を証明するにあたり，現在の実装モデル化し，それが安全性を満たすことを直接証明するのではなく，
本研究では多段階のrefinementにより証明する方針を取る．

状態遷移系$\s1$, $\s2$において，$\s1$により許される任意の (観測可能な) 状態の遷移列が$\s2$のそれでもあるとき，$\s1$は$\s2$のrefinementであるとよぶ．このとき，$\s2$が安全性を満たす場合には$\s1$も満たすことが示される．
Abadiらは，状態遷移系$\s1,\s2$において，$\s1$の状態を$\s2$の状態に写す関数で，ある条件を満たすものをrefinement mappingと定義した．
そしてそのmappingが存在する場合には$\s1$は$\s2$のrefinementになること (さらにある条件下ではその逆が成り立つこと) を示した\cite{refmap}．
Refinementの定義が状態の無限列の集合の包含関係に基づくことに対し，refinement mappingに関する条件はほとんどが状態間の対応関係を考えれば十分であり，証明が容易である．

Refinementの方針は次のようになる．
まず最上位のモデルとして，分散台帳ネットワークを外部からブラックボックスとして見た時の振る舞いをモジュール\textit{Ledger}としてモデル化する．
これは単一の状態機械として振る舞い，クライアントからのトランザクションを整列して順に状態に適用していけばよい．
次に，MVCC検証を行う台帳をモジュール\textit{MVCC\_Ledger}として定義する．
このモデルは依然として単一のノードとして振る舞うがMVCC検証を導入している．
トランザクションの投入時に仮実行結果を保存しておき，トランザクションの処理時にはMVCC検証を行い，成功したらRWSetをコミットすることにより状態の更新を行う．
最後に，より低位のモデルとして，複数のノードからのRWSetを収集するモデルをモジュール\textit{MVCC\_Consensus\_Ledger}として記述する．
なお，前述のアルゴリズムに現れるオーダラーについては取り除いて単純化しているが，これを陽にモデルで表現して検証することも可能である．


\begin{comment}
\subsection{とりあえず隔離}
ここではより限定された形のモデルを扱う。低位のモデル (= 実装)、高位のモデル (= 要求仕様) をそれぞれ $\s1$、$\s2$ とし、さらに $\s2$ は内部状態を持たないとする、つまり $\Sigma_2 = \Sigma_E$ とみなす。
またどちらのモデルも自明な liveness property を持つ、つまり $L_i = \Sigma_i^{\omega}$ とする。
このとき refinement mapping $f$ とは以下の条件を満たす $\Sigma_1$ から $\Sigma_2$への写像である。

\begin{enumerate}
\item すべての $s\in\Sigma_1$ について、$f(s) = \Pi_E(s)$
\item $f(F_1) \subseteq F_2$
\item $\p{ s,t }\in N_1$ ならば $\p{f(s), f(t)} \in N_2$ または $f(s)=f(t)$ である 
\end{enumerate}

このとき条件1より $f(\p{e, y}) = e$、つまり$f$は$\Sigma_E$への射影関数であることがわかる。これに従い前記条件2および3を書き直すと以下のようになる。

\begin{enumerate}
\item[2'] $\{ e \mid \p{e,y}\in F_1 \} \in F_2$
\item[3'] $\p{(e,y), (e',y')}\in N_1$ ならば $\p{e,e'} \in N_2$ または $e=e'$ である 
\end{enumerate}

さらに $\s1$ において、外部状態 $e$ は内部状態 $y$ の関数 $\pi$ であり、状態機械$\s1$は内部状態のみに依存して定義されていると仮定する。
このとき、前記条件はさらに以下のように変形できる。

\begin{enumerate}
\item[2''] $y \in F_1 \ra \pi(y) \in F_2$
\item[3''] $\p{y,y'}\in N_1$ ならば $\p{\pi(y),\pi(y')} \in N_2$ または $\pi(y)=\pi(y')$ である 
\end{enumerate}

これは\TLA においては$e \triangleq \pi(y)$とおいたうえで$L(y)!Spec \ra H(e)!Spec$を示すことに等しい。
これは前述の2''および3''を示すことにより\TLA で証明できる。

\begin{alignat}{2}
{} &\land L(y)!Init \ra H(e)!Init \\
{} &\land Inv \land L(y)!Next \ra Inv' \land \begin{aligned}[t]
	{}&\lor H(e)!Next \\
	{}&\lor \textsc{unchanged}\p{a,b,c}
	\end{aligned}
\end{alignat}
\end{comment}

\subsection{台帳仕様\textit{Ledger}}
最上位の台帳仕様である\textit{Ledger}から一部抜粋したものを図\ref{fig:led}に示す．
\begin{figure}[t!pbh]
\centering
\begin{minipage}{0.95\linewidth}
\lstinputlisting{Ledger.tla}
\caption{Ledgerモジュール (抜粋)}\label{fig:led}
\end{minipage}
\end{figure}

このモジュールは内部状態としてKVSの状態\textit{state}，ブロックチェーン\textit{chain}，チェーンにおける未処理のトランザクションのインデックスである\textit{index}を定義している (4--6行目)．
9--10行目ではデータ型に相当する集合を定義している．
なお\textit{TX}，\textit{NULL}などは共通モジュール\textit{Datatype}で定義されている．
12行目ではモジュールの初期状態を定義している\footnote{配列のインデックスは1から始まる．また，\url{<<a,b,c>>}は数学的記法では$\p{a,b,c}$と書き，タプルおよび配列を表す．当然であるがこれらもすべて集合である．}．
17--39行目では3種類の状態遷移に関する論理式を定義している．TLAではこれらをアクションとよび，TLAの名称の由来になっている．
例えばアクション\textit{ProcessTX\_OK} (21--29行目) はトランザクションの処理が成功した場合の状態遷移を定義している．トランザクションに格納されている関数，つまりスマートコントラクト (23行目の$f$) を現在の状態に適用し更新する．
ここでは$f$は非決定的であることを許容している．
処理したトランザクションにはvalidであるというフラグを付与し，インデックスを1つ進めている．
なお，\textit{ProcessTX\_ERR}は不要に見えるが，後にrefinement mappingを定義するためにこのようになっている．

次に，このモデルに対する安全性検証の例を図\ref{fig:ledinv}に示す．
不変条件としてはtype invariant (省略) に加えて，ブロックチェーンに含まれるトランザクションが前から順に処理されていること (\textit{ChainInv}) を含めている．
階層化された証明 (14--24行目) がTLAPSの記法に従って与えられている．
これにより\textit{Ledgder}が台帳として期待する性質を満たしていることが形式的に確認できる．
\begin{figure}[t!pbh]
\centering
\begin{minipage}{0.95\linewidth}
\lstinputlisting{LedgerInv.tla}
\caption{Ledgerモジュールの安全性 (抜粋)}\label{fig:ledinv}
\end{minipage}
\end{figure}


\subsection{MVCC台帳仕様\textit{MVCC\_Ledger}}
図\ref{fig:mvcc}に\textit{MVCC\_Ledger}モジュールを抜粋したものを示す．
ここではMVCC検証を導入するために，ブロックチェーンにエンドースメントを格納する箇所を設ける (3, 5行目)．
このモデルでは，トランザクションの投入時にエンドースメントを計算し格納するように変更されている (7--12行目)．
トランザクションの処理時にはread-setに関する条件が成功した場合の限り，RWSetをコミットすることにより\textit{state}の変更を行う (14--24行目)．
\begin{figure}[t!pbh]
\centering
\begin{minipage}{0.95\linewidth}
\lstinputlisting{MVCC_Ledger.tla}
\caption{MVCC\_Ledgerモジュール (抜粋)}\label{fig:mvcc}
\end{minipage}
\end{figure}

26--28行目ではrefinement mappingを定義している．エンドースメントに関するフィールドを削除する以外，変換はほぼ不要である．
30行目ではmappingされた変数を用いて上位モジュールである\textit{Leader}をインスタンス化している．
これにより，このモジュールが\textit{Ledger}のrefinementとなることは，39行目の命題\textit{Refinement}で表現できる．
詳細は省略するが，これはrefinement mappingの定義\cite{refmap}において，$\s2$が内部状態を持たず，$\s1$の外部状態が内部状態の関数として定義される場合に相当する．
%証明はモジュール間のアクションの対応関係を示すことにより進められる．
%Mappingに伴う状態変数の同値性を示すところが煩雑ではあるが，証明構造としては単純である．

\subsection{MVCCコンセンサス台帳仕様\textit{MVCC\_Consensus\_Ledger}}
このモデルにおいては複数のノードからのRWSetをエンドースメントとして収集する．
したがって，\textit{Endorsement}の定義を\textit{RWSet}から$\textit{Seq}(\textit{RWSet})$に変更する必要がある．
さらに，トランザクションを投入する際にネットワーク環境を反映した適切なエンドースメントを生成する必要がある．
例えば4台のノード中高々1台がビザンチン障害にあるという設定であれば，エンドースメントの数は0-4個であり，そのうち高々1つが障害ノードからのRWSetであるとする．
そして障害ノードからのRWSetの中身は任意のデータであり，その他のRWSetは正しい仮実行結果である，とすればよい．
TLAの非決定的代入はこのようなモデル化に極めて有用である．

あとはこのモジュールが\textit{MVCC\_Ledger}のrefinementであることを示せばよく，これは命題 $\textit{Spec} \ra \textit{MVCC\_Ledger}!\textit{Spec}$ を証明すればよい．
紙面の都合上，詳細は省略する．

\section{考察}
\label{sec:consider}

\subsection{\TLA によるモデル化と検証の容易性}
前述したように\TLA にはデータ型が存在せず，すべて集合として扱われる．例えば自然数は自然数型\texttt{Nat}を持つ値，ではなくて自然数の集合$\mathit{Nat}$の元であるとみなされる．

型を扱わないことにはメリットとデメリットがある．
\TLA で記述される仕様は検証対象のシステムと外部の環境をまとめて扱うclosed-system specificationである．その際，環境から与えられる値に関しては型を制限しないことが現実のモデル化という観点からは望ましい．
一方で，型システムが導入されていれば自明であるにもかかわらず，\TLA では値がどの集合に属するか証明する必要がある場合が多く効率的でない．
現実的にはシステムの内部で扱うデータは統制されていることがほとんどであるから，部分的に型を指定・推論できる仕組みがあると便利である．
%また，\TLA では集合をfirst-classとして扱うことにより非構成的な記述および証明が可能である反面，Coqなどと比べて証明が煩雑になるケースもみられる．

\TLA の証明支援系であるTLAPSは自然演繹に基づく前向き推論を採用している．
Coq などに見られる後ろ向きの推論とは異なり，現在のゴールが自動的に構築されるわけではないので，試行錯誤が必要になるケース多いが，IDEのサポートが十分であるとは言い難い．
他の証明支援系でも見られるようにSMTソルバなどを用いた自動証明は利便性が高いが，ゴールに対して適用する定理をピンポイントで指定する形式ではないので，意図した証明にたどり着くのに苦労するケースも見られる．
%また，ゴールに含まれれるどの定義を展開するかを手動で与える必要がある．
%これが自動化されるとさらに有用であると思われる．

なお，\TLA にはモデル検査器が付属しているが，少し複雑な仕様に対しては状態爆発により現実的な時間では検証が完了せず，今回は使用を見送った．

\subsection{モデルと実装の整合性}

形式検証の課題の1つとして，モデルと実装\footnote{ここでいう実装は，プログラミング言語による実装を指す．}の乖離がある．

まず，先に要求仕様としてのモデルを作成・検証し，それをもとにコードを実装する場合を考える．
分散プロトコルを一からデザインする場合にはこちらのアプローチが望ましい．
このとき，モデルが正しいことを検証できたとしても，実装へ抽出または変換する際に誤りがあると形式検証を行った意味が失われる．
この主要な原因としてはモデルの記述力が低いことなどに起因してモデルが単純化されすぎている場合と，逆に記述力が高すぎるため，プログラミング言語で実装可能なコードに変換する際に誤りが混入する場合があると考えられる．
\TLA の場合は後者にあたる可能性が大きい．
\TLA におけるoperationはマクロ的な働きをする上に，様々なデータ型や操作が集合およびその上の演算として表現されている．
集合には内包表記が使用可能で，さらに非決定的代入も存在する．
これらは\TLA で記述する際には頻出するが，例えばGo言語のような低レベル言語で直接に実装するのは難しい．
この場合には，上記のモデルをいったん実装に近い形に詳細化して，それをプログラムに変換するのが望ましい．

一方，実装がすでに存在し，その性質を検証する場合にはモデルが実装の振る舞いを正しく反映しているかが問題となる．
この場合，実装から自動的にモデルを抽出することが望ましい．
Hyperledger Fabricの場合はすでに実装があり，バージョンアップが頻繁であるため，現在のところはこのアプローチが現実的であると思われる．
しかし実際に動作するレベルのコードから変換して検証器が耐えうる程度の規模のモデルに収まるかについては未知数である．

\section{関連研究}
\label{sec:related}

これまでに様々な形式検証系が研究されている．

関数型言語をベースとしたものではCoq, Agda, Isabelle/HOLが著名である．
これらは帰納データ型とタクティクに基づく豊富な証明能力があるが，デフォルトでは時相論理を扱えないため今回は採用しなかった．
なお，CoqにLogic of Eventsと呼ばれる理論を導入し，PBFTアルゴリズムの検証を行った研究がある\cite{Velisarios}．
Coqには証明からプログラムを抽出する機能があり，形式検証で問題になるモデルと実装の乖離を防ぐ意味で有用な手法であると思われる．

\TLA ではPaxos，Raftを始めとする分散合意プロトコルが検証されている．

状態遷移系 (Kripke構造) をベースとするものには\TLA の他にEvent-BやNuSMVが挙げられる．
前者は定理証明ベースであり後者はモデル検査器を使用する．
これらの中では\TLA がもっとも記述の自由度が高い．
%たとえばEvent-Bはモジュールの概念がないため，大規模なシステムを記述することにはあまり向かない．
%また，基本的なデータ型しか存在しないために実装に近い記述をすることには困難が伴う．
%時相論理で性質を記述することができないことも欠点である．
NuSMVは時相論理で性質を記述することができ，モジュールの概念がある．
ただし複数のモジュールが非同期的に動作するようなモデルを容易には書きにくい\footnote{厳密に言うと現在はその機能があるが削除予定である．}．またモデル検査の都合上有限の状態遷移しか許されない．

また，並行プロセス計算である$\pi$計算に基づくものとしてProVerifがある．
これはセキュリティプロトコルの検証に特化しており，「イベントAが起きたときには必ず過去にイベントBが起きている」といった他の検証器にはない，後ろ向きの性質が記述できるが，一方で記述できない時相論理式が多い．
そのため今回のような一般の分散システム検証には不向きである．

\section{まとめ}
本論文ではパーミッション型の分散台帳技術であるHyperledger Fabricの安全性に関する形式検証を行った．
Fabricのコンセンサスアルゴリズムの主要部分を取り出したものについて，低レベルのモデル (実装) が高レベルのモデル (仕様) を詳細化していることを証明することによりその安全性を検証した．
形式検証系には集合論および時相論理をベースとする\TLA を用いた．
豊富なデータ型とSMTソルバなどを用いた定理証明器により，シンプルに証明を構築することができた．
現在の\TLA のモデル検査器の性能が向上すれば，定理証明とモデル検査を組み合わせることにより，さらに効率の良い検証が可能になると思われる．
今後の研究はFabricの独自機能をさらに盛り込むこと，プログラミング言語による実装とモデルの対応を正しく取ることについて取り組んでいきたい．

\begin{comment}
\section{表と図}

表の例を表\ref{tab:example}に，
図の例を図\ref{fig:example}に示します．

\begin{table}[htbp]
  \centering
  \caption{表の例} \label{tab:example}
  \begin{tabular}{|l|l|l|}\hline
    FOSE2013 & ソフトウェア工学の基礎 XX & 岡野 浩三，関澤 俊弦 編 \\ \hline
    FOSE2014 & ソフトウェア工学の基礎 XXI& 花川 典子，尾花 将輝 編\\ \hline
    FOSE2015 & ソフトウェア工学の基礎XXII & 青木 利晃，豊島 真澄 編\\ \hline
    FOSE2016 & ソフトウェア工学の基礎XXIII & 阿萬 裕久，横川 智教 編\\ \hline
    FOSE2017 & ソフトウェア工学の基礎XXIV & 吉田 敦，福安 直樹 編\\ \hline
    FOSE2018 & ソフトウェア工学の基礎XXV & 伊藤 恵，神谷 年洋  編\\ \hline
  \end{tabular}
\end{table}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{fose2005logo.eps}
%  \epsfig{file=fose2005logo.eps,width=\textwidth}
  \caption{図の例(FOSE2005のロゴを使わせてもらっております)}
  \label{fig:example}
\end{figure}
\end{comment}


%\acknowledgements{test}
%あれば書く。

\bibliographystyle{junsrt}
\bibliography{mybib}
\end{document}
