# 実験コードの動かし方

ここでは主に定理の書き方と証明の仕方について説明

# TLA Toolbox を起動

- 社内PCからはアイコンでの直接起動ができない可能性が高い。コンソールから直接 `TLA+ Toolbox.app/Contents/MacOS/toolbox` を起動する

# Spec を開く

既存の Spec の場合は:

- `File > Open Spec > Add New Spec...` を選択。新規作成に見えるがこれで大丈夫である。

新規 Spec の作成は:

- `File > Open Spec > Add New Spec...` を選択
- ルートモジュール (.tla ファイル) の名前と Spec 名を決める必要がある。前者は適当な場所で作りたい `.tla` ファイルを指定する。Spec 名は自動的に決まる
  - ダイアログの上の方に "A new file will be created." が見える

# Spec と証明を書く

新規作成の場合は雛形が自動で作成されるので `---- MODULE <module> ----` と `====` の間に書く。

前提または公理は `ASSUME` や `AXIOM` で書く。
命題変数を定義したいだけなら `CONSTANTS` で宣言する。
定理はたとえば `THEOREM Existence == TRUE` のように書く。左辺は定理名である。

# 証明する

`THEOREM` の行にカーソルを合わせて `コマンド-g コマンド-g` とすると証明の確認が行われれる。
まだ証明を書いていないので行が黄色くなる。
次の行に証明を ｀OBVIOUS` と書く。まだ上の行は黄色いままである。

ここで、`THEOREM` の行にカーソルを合わせてふたたび `コマンド-g コマンド-g` とすると行が緑になり、証明完了したことが示される。

基本的には前向きの自然演繹スタイルである。

```
THEOREM (または LEMMA) <定理名> == <命題>
<1>1. 命題1
...
<1>n. 命題N
<1> QED BY <1>1., ..., <1>n
```

`<>` の中の数字は証明木の深さを表している。その後の数字や文字はラベルであり、あとでその命題 (とその証明) を参照するために使う。

単純な証明の場合にはより簡潔に書けるようになっている。命題が「明らか」な場合の `OBVIOUS` と、他の定理を用いる `BY ... DEF ...` について説明する。
これらを使う場合は先頭に `<番号>` を付ける必要はない。

## OBVIOUS (`Th1`)

単純な命題の場合 (命題論理のトートロジーなど) は以下のようにして証明できる。

```
<命題>
  OBVIOUS
```

## `BY ... DEF ...`

変数の展開で証明できる場合は

```
<命題>
  BY DEF <命題名>, ..., <命題名>
```

変数を展開した上で他の前提を利用する場合は

```
<命題>
  BY <前提1>, ..., <前提n> DEF <命題名>, ..., <命題名>
```

## 命題論理トートロジー (`Th2`)

たとえば `P /\ Q ＝＞ Q /\ P` くらいなら同様に `OBVIOUS` で証明してくれる。

## 変数展開 (`Th3`)

`AXIOM` や `ASSUME` はデフォルトで展開される。
たぶんどちらも "usable" な命題に含まれている。

## 明示的な変数展開 (`Th4`)

命題を宣言なしで単純に定義すると自動では展開されない。
`DEF` で展開する。他の定理を適用しない場合は `BY DEF <定義名>, ...` でおこなう。

## 自然数を入れてみる (`Th5`, `Th5b`, `Th5c`)

自然数を入れて存在命題の証明を試みる。ドメインが無限の場合は `OBVIOUS` では証明してくれない。
この場合、命題の行が赤い色になっている。
`Intereresting Obligation for...` のウィンドウに注目している命題が表示されている。
範囲を限定するとSMTソルバで求解してくれる

存在命題はドメインを指定しないことも可能である (`Th5c`)。

# タクティクス

## `ASSUME PROVE` (Tac_) 

証明中に、命題を導入する場合は以下のように書く

```
<m> ASSUME <P1>, ..., <Pn> PROVE Q
  <m+1> Qの証明
  ...
```

命題 `P1 /\ ... /\ Pn => Q` の提示である。子レベルでその証明を行う。
命題の全件を分解するのにも使う (Coq の `intro` みたいな用法)

まず、タクティックの直後で `P => Q` を証明する。
残りのステップで `P` を証明するための材料を集める。
最後に `QED` で `P` の証明を行う。

## `SUFFICES` (Tac_1)

大抵の場合 `ASSUME` は `SUFFICES` とともに用いられる。
これは証明の順番を入れ替えることができる。

```
...
(現在のゴールがQであるとき)
<m> SUFFICES P
   <m+1> Pを仮定してのQの証明...
   ...
   <m+1> QED
<m> Pの証明
...
<m> QED
```

## `HAVE`

ゴールが `P => Q` であるとき、

```
<m>l. HAVE G
```

はGを仮定してQを証明することに帰着するタクティックである。これは次のものと等価である:

```
<m>l. SUFFICES ASSUME G PROVE Q
  OBVIOUS
```

想定としては `G => Q` が容易に証明できる場合に、`P => G` を示すことにより、MPを用いてゴールを証明できる、とするものである (と思われる)。

## `TAKE`

ゴールが `\A x: P(x)` または `\A x \in S: P(x)` であるときには、任意の `y` を取ってきて議論を進める必要がある。

```
<n>l. TAKE y
または
<n>l. TAKE y \in T
```

はそのためのタクティックである。これは

```
<n>l. SUFFICES ASSUME NEW y PROVE P(y)
  OBVIOUS
```

または

```
<n>l. SUFFICES ASSUME NEW y \in T PROVE P(y)
  OBVIOUS
```

と等価である。後者の場合はおそらく、`S` が `T` のsubsetであることを示さなければならないのでは。

## `WITNESS`

ゴールが存在命題 `\E x : P(x)` や `\E x \in S : P(x)` の場合は、`P` を満たす `x` の存在を示す必要がある。
これは

```
<n>l. WITNESS e
または
<n>l. WITNESS e \in T
```

なるタクティックを用いることで証明できる。これは

```
<n>l. SUFFICES P(e)
  OBVIOUS
```

または

と等価である
## `PICK`